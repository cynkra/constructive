<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Constructive options for type 'environment' — opts_environment • constructive</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Constructive options for type 'environment' — opts_environment"><meta name="description" content="Environments use reference semantics, they cannot be copied.
An attempt to copy an environment would indeed yield a different environment and identical(env, copy) would be FALSE.
Moreover most environments have a parent (exceptions are emptyenv() and some
rare cases where the parent is NULL) and thus to copy the environment we'd
have to have a way to point to the parent, or copy it too.
For this reason environments are constructive's cryptonite. They make some objects
impossible to reproduce exactly. And since every function or formula has one they're hard to
avoid. "><meta property="og:description" content="Environments use reference semantics, they cannot be copied.
An attempt to copy an environment would indeed yield a different environment and identical(env, copy) would be FALSE.
Moreover most environments have a parent (exceptions are emptyenv() and some
rare cases where the parent is NULL) and thus to copy the environment we'd
have to have a way to point to the parent, or copy it too.
For this reason environments are constructive's cryptonite. They make some objects
impossible to reproduce exactly. And since every function or formula has one they're hard to
avoid. "></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">constructive</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/extend-constructive.html">Extend constructive</a></li>
  </ul></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/cynkra/constructive/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Constructive options for type 'environment'</h1>
      <small class="dont-index">Source: <a href="https://github.com/cynkra/constructive/blob/main/R/s3-environment.R" class="external-link"><code>R/s3-environment.R</code></a></small>
      <div class="d-none name"><code>opts_environment.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Environments use reference semantics, they cannot be copied.
An attempt to copy an environment would indeed yield a different environment and <code>identical(env, copy)</code> would be <code>FALSE</code>.<br>
Moreover most environments have a parent (exceptions are <code><a href="https://rdrr.io/r/base/environment.html" class="external-link">emptyenv()</a></code> and some
rare cases where the parent is <code>NULL</code>) and thus to copy the environment we'd
have to have a way to point to the parent, or copy it too. <br>
For this reason environments are <span class="pkg">constructive</span>'s cryptonite. They make some objects
impossible to reproduce exactly. And since every function or formula has one they're hard to
avoid. <br></p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">opts_environment</span><span class="op">(</span></span>
<span>  constructor <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">".env"</span>, <span class="st">"list2env"</span>, <span class="st">"as.environment"</span>, <span class="st">"new.env"</span>, <span class="st">"topenv"</span>,</span>
<span>    <span class="st">"new_environment"</span>, <span class="st">"predefine"</span><span class="op">)</span>,</span>
<span>  <span class="va">...</span>,</span>
<span>  recurse <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-constructor">constructor<a class="anchor" aria-label="anchor" href="#arg-constructor"></a></dt>
<dd><p>String. Name of the function used to construct the
environment, see <strong>Constructors</strong> section.</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>Additional options used by user defined constructors through the <code>opts</code> object</p></dd>


<dt id="arg-recurse">recurse<a class="anchor" aria-label="anchor" href="#arg-recurse"></a></dt>
<dd><p>Boolean. Only considered if <code>constructor</code> is <code>"list2env"</code> or
<code>"new_environment"</code>. Whether to attempt to recreate all parent environments
until a known environment is found, if <code>FALSE</code> (the default) we will use
<code><a href="https://rdrr.io/r/base/ns-topenv.html" class="external-link">topenv()</a></code> to find a known ancestor to set as the parent.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>An object of class &lt;constructive_options/constructive_options_environment&gt;</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>In some case we can build code that points to a specific environment, namely:</p><ul><li><p><code>.GlobalEnv</code>, <code>.BaseNamespaceEnv</code>, <code><a href="https://rdrr.io/r/base/environment.html" class="external-link">baseenv()</a></code> and <code><a href="https://rdrr.io/r/base/environment.html" class="external-link">emptyenv()</a></code> are used to construct
the global environment, the base namespace, the base package environment and the empty
environment</p></li>
<li><p>Namespaces are constructed using <code>asNamespace("pkg")</code></p></li>
<li><p>Package environments are constructed using <code>as.environment("package:pkg")</code></p></li>
<li><p>"imports" environments are constructed with <code>parent.env(asNamespace("pkg"))</code></p></li>
<li><p>"lazydata" environments are constructed with <code>getNamespaceInfo("pkg", "lazydata")</code></p></li>
</ul><p>By default For other environments we use <span class="pkg">constructive</span>'s function <code><a href="dot-env.html">constructive::.env()</a></code>, it fetches
the environment from its memory address and provides as additional information
the sequence of parents until we reach a special environment (those enumerated above).
The advantage of this approach is that it's readable and that the object is accurately reproduced.
The inconvenient is that it's not stable between sessions. If an environment has a <code>NULL</code> parent it's always constructed
with <code><a href="dot-env.html">constructive::.env()</a></code>, whatever the choice of the constructor.</p>
<p>Often however we wish to be able to reproduce from scratch a similar environment,
so that we might run the constructed code later in a new session. We offer different
different options to do this, with different trade-offs regarding accuracy and verbosity.</p>
<p>{constructive} will not signal any difference if it can reproduce an equivalent environment,
defined as containing the same values and having a same or equivalent parent.<br></p>
<p>See also the <code>ignore_function_env</code> argument in <code><a href="compare_options.html">?compare_options</a></code>, which disables the check
of environments of function.</p>
    </div>
    <div class="section level2">
    <h2 id="constructors">Constructors<a class="anchor" aria-label="anchor" href="#constructors"></a></h2>



<p>We might set the <code>constructor</code> argument to:</p><ul><li><p><code>".env"</code> (default): use <code><a href="dot-env.html">constructive::.env()</a></code> to construct the environment from
its memory address.</p></li>
</ul><ul><li><p><code>"list2env"</code>: We construct the environment as a list then
use <code><a href="https://rdrr.io/r/base/list2env.html" class="external-link">base::list2env()</a></code> to convert it to an environment and assign it a parent. By
default we will use <code><a href="https://rdrr.io/r/base/ns-topenv.html" class="external-link">base::topenv()</a></code> to construct a parent. If <code>recurse</code> is <code>TRUE</code>
the parent will be built recursively so all ancestors will be created until
we meet a known environment, this might be verbose and will fail if environments
are nested too deep or have a circular relationship. If the environment is empty we use <code>new.env(parent=)</code>
for a more economic syntax.</p></li>
<li><p><code>"new_environment"</code> : Similar to the above, but using <code><a href="https://rlang.r-lib.org/reference/env.html" class="external-link">rlang::new_environment()</a></code>.</p></li>
<li><p><code>"new.env"</code> : All environments will be recreated with the code <code>"base::new.env()"</code>,
without argument, effectively creating an empty environment child of
the local (often global) environment. This is enough in cases where the environment
doesn't matter (or matters as long as it inherits from the local environment),
as is often the case with formulas. <code>recurse</code> is ignored.</p></li>
<li><p><code>"as.environment"</code> : we attempt to construct the environment as a list and use
<code><a href="https://rdrr.io/r/base/as.environment.html" class="external-link">base::as.environment()</a></code> on top of it, as in <code>as.environment(list(a=1, b=2))</code>, it will
contain the same variables as the original environment but the parent will be the
<code><a href="https://rdrr.io/r/base/environment.html" class="external-link">emptyenv()</a></code>. <code>recurse</code> is ignored.</p></li>
<li><p><code>"topenv"</code> : we construct <code>base::topenv(x)</code>, see <code><a href="https://rdrr.io/r/base/ns-topenv.html" class="external-link">?topenv</a></code>. <code>recurse</code> is ignored.
This is the most accurate we can be when constructing only special environments.</p></li>
<li><p><code>"predefine"</code> : Building environments from scratch using the above methods
can be verbose, sometimes redundant and sometimes even impossible due to
circularity (e.g. an environment referencing itself).  With <code>"predefine"</code>
we define the environments and their content  above the object returning
call, using placeholder names <code>..env.1..</code>, <code>..env.2..</code> etc.
The caveat is that the created code won't be a single call
and will create objects in the workspace. <code>recurse</code> is ignored.</p></li>
</ul></div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Antoine Fabri.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.9000.</p>
</div>

    </footer></div>





  </body></html>

