
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "duckplyr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('duckplyr')
The duckplyr package is configured to fall back to dplyr when it encounters an
incompatibility. Fallback events can be collected and uploaded for analysis to
guide future development. By default, no data will be collected or uploaded.
→ Run `duckplyr::fallback_sitrep()` to review the current settings.
✔ Overwriting dplyr methods with duckplyr methods.
ℹ Turn off with `duckplyr::methods_restore()`.

Attaching package: ‘duckplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("as_duckplyr_df")
> ### * as_duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_duckplyr_df
> ### Title: Convert to a duckplyr data frame
> ### Aliases: as_duckplyr_df as_duckplyr_tibble
> 
> ### ** Examples
> 
> tibble(a = 1:3) %>%
+   mutate(b = a + 1)
# A tibble: 3 × 2
      a     b
  <int> <dbl>
1     1     2
2     2     3
3     3     4
> 
> tibble(a = 1:3) %>%
+   as_duckplyr_df() %>%
+   mutate(b = a + 1)
duckplyr: materializing
# A tibble: 3 × 2
      a     b
  <int> <dbl>
1     1     2
2     2     3
3     3     4
> 
> 
> 
> cleanEx()
> nameEx("config")
> ### * config
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: config
> ### Title: Configuration options
> ### Aliases: config
> 
> ### ** Examples
> 
> # options(duckdb.materialize_message = FALSE)
> data.frame(a = 3:1) %>%
+   as_duckplyr_df() %>%
+   inner_join(data.frame(a = 1:4), by = "a")
duckplyr: materializing
  a
1 1
2 2
3 3
> 
> rlang::with_options(duckdb.materialize_message = FALSE, {
+   data.frame(a = 3:1) %>%
+     as_duckplyr_df() %>%
+     inner_join(data.frame(a = 1:4), by = "a") %>%
+     print()
+ })
  a
1 1
2 2
3 3
> 
> # Sys.setenv(DUCKPLYR_OUTPUT_ORDER = TRUE)
> data.frame(a = 3:1) %>%
+   as_duckplyr_df() %>%
+   inner_join(data.frame(a = 1:4), by = "a")
duckplyr: materializing
  a
1 1
2 2
3 3
> 
> withr::with_envvar(c(DUCKPLYR_OUTPUT_ORDER = "TRUE"), {
+   data.frame(a = 3:1) %>%
+     as_duckplyr_df() %>%
+     inner_join(data.frame(a = 1:4), by = "a")
+ })
duckplyr: materializing
  a
1 3
2 2
3 1
> 
> # Sys.setenv(DUCKPLYR_FORCE = TRUE)
> add_one <- function(x) {
+   x + 1
+ }
> 
> data.frame(a = 3:1) %>%
+   as_duckplyr_df() %>%
+   mutate(b = add_one(a))
The duckplyr package is configured to fall back to dplyr when it encounters an
incompatibility. Fallback events can be collected and uploaded for analysis to
guide future development. By default, no data will be collected or uploaded.
ℹ A fallback situation just occurred. The following information would have been
  recorded:
  {"version":"0.4.1","message":"No translation for function
  `add_one`.","name":"mutate","x":{"...1":"integer"},"args":{"dots":{"...2":"add_one(...1)"},".by":"NULL",".keep":["all","used","unused","none"]}}
→ Run `duckplyr::fallback_sitrep()` to review the current settings.
→ Run `Sys.setenv(DUCKPLYR_FALLBACK_COLLECT = 1)` to enable fallback logging,
  and `Sys.setenv(DUCKPLYR_FALLBACK_VERBOSE = TRUE)` in addition to enable
  printing of fallback situations to the console.
→ Run `duckplyr::fallback_review()` to review the available reports, and
  `duckplyr::fallback_upload()` to upload them.
ℹ See `?duckplyr::fallback()` for details.
ℹ This message will be displayed once every eight hours.
  a b
1 3 4
2 2 3
3 1 2
> 
> try(withr::with_envvar(c(DUCKPLYR_FORCE = "TRUE"), {
+   data.frame(a = 3:1) %>%
+     as_duckplyr_df() %>%
+     mutate(b = add_one(a))
+ }))
Error in rel_find_call(expr[[1]], env) : 
  No translation for function `add_one`.
> 
> # Sys.setenv(DUCKPLYR_FALLBACK_INFO = TRUE)
> withr::with_envvar(c(DUCKPLYR_FALLBACK_INFO = "TRUE"), {
+   data.frame(a = 3:1) %>%
+     as_duckplyr_df() %>%
+     mutate(b = add_one(a))
+ })
Error processing with relational.
Caused by error in `rel_find_call()`:
! No translation for function `add_one`.  a b
1 3 4
2 2 3
3 1 2
> 
> 
> 
> cleanEx()
> nameEx("df_from_file")
> ### * df_from_file
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: df_from_file
> ### Title: Read Parquet, CSV, and other files using DuckDB
> ### Aliases: df_from_file duckplyr_df_from_file df_from_csv
> ###   duckplyr_df_from_csv df_from_parquet duckplyr_df_from_parquet
> ###   df_to_parquet
> 
> ### ** Examples
> 
> # Create simple CSV file
> path <- tempfile("duckplyr_test_", fileext = ".csv")
> write.csv(data.frame(a = 1:3, b = letters[4:6]), path, row.names = FALSE)
> 
> # Reading is immediate
> df <- df_from_csv(path)
> 
> # Materialization only upon access
> names(df)
[1] "a" "b"
> df$a
duckplyr: materializing
[1] 1 2 3
> 
> # Return as tibble, specify column types:
> df_from_file(
+   path,
+   "read_csv",
+   options = list(delim = ",", types = list(c("DOUBLE", "VARCHAR"))),
+   class = class(tibble())
+ )
duckplyr: materializing
# A tibble: 3 × 2
      a b    
  <dbl> <chr>
1     1 d    
2     2 e    
3     3 f    
> 
> # Read multiple file at once
> path2 <- tempfile("duckplyr_test_", fileext = ".csv")
> write.csv(data.frame(a = 4:6, b = letters[7:9]), path2, row.names = FALSE)
> 
> duckplyr_df_from_csv(file.path(tempdir(), "duckplyr_test_*.csv"))
duckplyr: materializing
# A tibble: 6 × 2
      a b    
  <dbl> <chr>
1     4 g    
2     5 h    
3     6 i    
4     1 d    
5     2 e    
6     3 f    
> 
> unlink(c(path, path2))
> 
> # Write a Parquet file:
> path_parquet <- tempfile(fileext = ".parquet")
> df_to_parquet(df, path_parquet)
NULL
> 
> # With a duckplyr_df, the materialization occurs outside of R:
> df %>%
+   as_duckplyr_df() %>%
+   mutate(b = a + 1) %>%
+   df_to_parquet(path_parquet)
NULL
> 
> duckplyr_df_from_parquet(path_parquet)
duckplyr: materializing
# A tibble: 3 × 2
      a     b
  <dbl> <dbl>
1     1     2
2     2     3
3     3     4
> 
> unlink(path_parquet)
> 
> 
> 
> cleanEx()
> nameEx("fallback")
> ### * fallback
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fallback
> ### Title: Fallback to dplyr
> ### Aliases: fallback fallback_sitrep fallback_review fallback_upload
> ###   fallback_purge
> 
> ### ** Examples
> 
> fallback_sitrep()
The duckplyr package is configured to fall back to dplyr when it encounters an
incompatibility. Fallback events can be collected and uploaded for analysis to
guide future development. By default, no data will be collected or uploaded.
ℹ Fallback logging is not controlled and therefore disabled. Enable it with
  `Sys.setenv(DUCKPLYR_FALLBACK_COLLECT = 1)`, disable it with
  `Sys.setenv(DUCKPLYR_FALLBACK_COLLECT = 0)`.
ℹ Fallback uploading is not controlled and therefore disabled. Enable it with
  `Sys.setenv(DUCKPLYR_FALLBACK_AUTOUPLOAD = 1)`, disable it with
  `Sys.setenv(DUCKPLYR_FALLBACK_AUTOUPLOAD = 0)`.
ℹ See `?duckplyr::fallback()` for details.
> 
> 
> 
> cleanEx()
> nameEx("is_duckplyr_df")
> ### * is_duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_duckplyr_df
> ### Title: Class predicate for duckplyr data frames
> ### Aliases: is_duckplyr_df
> 
> ### ** Examples
> 
> tibble(a = 1:3) %>%
+   is_duckplyr_df()
[1] FALSE
> 
> tibble(a = 1:3) %>%
+   as_duckplyr_df() %>%
+   is_duckplyr_df()
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("methods_overwrite")
> ### * methods_overwrite
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods_overwrite
> ### Title: Forward all dplyr methods to duckplyr
> ### Aliases: methods_overwrite methods_restore
> 
> ### ** Examples
> 
> tibble(a = 1:3) %>%
+   mutate(b = a + 1)
# A tibble: 3 × 2
      a     b
  <int> <dbl>
1     1     2
2     2     3
3     3     4
> 
> methods_overwrite()
✔ Overwriting dplyr methods with duckplyr methods.
ℹ Turn off with `duckplyr::methods_restore()`.
> 
> tibble(a = 1:3) %>%
+   mutate(b = a + 1)
duckplyr: materializing
# A tibble: 3 × 2
      a     b
  <int> <dbl>
1     1     2
2     2     3
3     3     4
> 
> methods_restore()
ℹ Restoring dplyr methods.
> 
> tibble(a = 1:3) %>%
+   mutate(b = a + 1)
# A tibble: 3 × 2
      a     b
  <int> <dbl>
1     1     2
2     2     3
3     3     4
> 
> 
> 
> cleanEx()
> nameEx("new_relational")
> ### * new_relational
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: new_relational
> ### Title: Relational implementer's interface
> ### Aliases: new_relational rel_to_df rel_filter rel_project rel_aggregate
> ###   rel_order rel_join rel_limit rel_distinct rel_set_intersect
> ###   rel_set_diff rel_set_symdiff rel_union_all rel_explain rel_alias
> ###   rel_set_alias rel_names
> 
> ### ** Examples
> 
> new_dfrel <- function(x) {
+   stopifnot(is.data.frame(x))
+   new_relational(list(x), class = "dfrel")
+ }
> mtcars_rel <- new_dfrel(mtcars[1:5, 1:4])
> 
> rel_to_df.dfrel <- function(rel, ...) {
+   unclass(rel)[[1]]
+ }
> rel_to_df(mtcars_rel)
                   mpg cyl disp  hp
Mazda RX4         21.0   6  160 110
Mazda RX4 Wag     21.0   6  160 110
Datsun 710        22.8   4  108  93
Hornet 4 Drive    21.4   6  258 110
Hornet Sportabout 18.7   8  360 175
> 
> rel_filter.dfrel <- function(rel, exprs, ...) {
+   df <- unclass(rel)[[1]]
+ 
+   # A real implementation would evaluate the predicates defined
+   # by the exprs argument
+   new_dfrel(df[seq_len(min(3, nrow(df))), ])
+ }
> 
> rel_filter(
+   mtcars_rel,
+   list(
+     relexpr_function(
+       "gt",
+       list(relexpr_reference("cyl"), relexpr_constant("6"))
+     )
+   )
+ )
[[1]]
               mpg cyl disp  hp
Mazda RX4     21.0   6  160 110
Mazda RX4 Wag 21.0   6  160 110
Datsun 710    22.8   4  108  93

attr(,"class")
[1] "dfrel"      "relational"
> 
> rel_project.dfrel <- function(rel, exprs, ...) {
+   df <- unclass(rel)[[1]]
+ 
+   # A real implementation would evaluate the expressions defined
+   # by the exprs argument
+   new_dfrel(df[seq_len(min(3, ncol(df)))])
+ }
> 
> rel_project(
+   mtcars_rel,
+   list(relexpr_reference("cyl"), relexpr_reference("disp"))
+ )
[[1]]
                   mpg cyl disp
Mazda RX4         21.0   6  160
Mazda RX4 Wag     21.0   6  160
Datsun 710        22.8   4  108
Hornet 4 Drive    21.4   6  258
Hornet Sportabout 18.7   8  360

attr(,"class")
[1] "dfrel"      "relational"
> 
> rel_order.dfrel <- function(rel, exprs, ...) {
+   df <- unclass(rel)[[1]]
+ 
+   # A real implementation would evaluate the expressions defined
+   # by the exprs argument
+   new_dfrel(df[order(df[[1]]), ])
+ }
> 
> rel_order(
+   mtcars_rel,
+   list(relexpr_reference("mpg"))
+ )
[[1]]
                   mpg cyl disp  hp
Hornet Sportabout 18.7   8  360 175
Mazda RX4         21.0   6  160 110
Mazda RX4 Wag     21.0   6  160 110
Hornet 4 Drive    21.4   6  258 110
Datsun 710        22.8   4  108  93

attr(,"class")
[1] "dfrel"      "relational"
> ## Don't show: 
> if (requireNamespace("dplyr", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ rel_join.dfrel <- function(left, right, conds, join, ...) {
+   left_df <- unclass(left)[[1]]
+   right_df <- unclass(right)[[1]]
+ 
+   # A real implementation would evaluate the expressions
+   # defined by the conds argument,
+   # use different join types based on the join argument,
+   # and implement the join itself instead of relaying to left_join().
+   new_dfrel(dplyr::left_join(left_df, right_df))
+ }
+ 
+ rel_join(new_dfrel(data.frame(mpg = 21)), mtcars_rel)
+ ## Don't show: 
+ }) # examplesIf
> rel_join.dfrel <- function(left, right, conds, join, ...) {
+     left_df <- unclass(left)[[1]]
+     right_df <- unclass(right)[[1]]
+     new_dfrel(dplyr::left_join(left_df, right_df))
+ }
> rel_join(new_dfrel(data.frame(mpg = 21)), mtcars_rel)
Joining with `by = join_by(mpg)`
[[1]]
  mpg cyl disp  hp
1  21   6  160 110
2  21   6  160 110

attr(,"class")
[1] "dfrel"      "relational"
> ## End(Don't show)
> 
> rel_limit.dfrel <- function(rel, n, ...) {
+   df <- unclass(rel)[[1]]
+ 
+   new_dfrel(df[seq_len(n), ])
+ }
> 
> rel_limit(mtcars_rel, 3)
[[1]]
               mpg cyl disp  hp
Mazda RX4     21.0   6  160 110
Mazda RX4 Wag 21.0   6  160 110
Datsun 710    22.8   4  108  93

attr(,"class")
[1] "dfrel"      "relational"
> 
> rel_distinct.dfrel <- function(rel, ...) {
+   df <- unclass(rel)[[1]]
+ 
+   new_dfrel(df[!duplicated(df), ])
+ }
> 
> rel_distinct(new_dfrel(mtcars[1:3, 1:4]))
[[1]]
            mpg cyl disp  hp
Mazda RX4  21.0   6  160 110
Datsun 710 22.8   4  108  93

attr(,"class")
[1] "dfrel"      "relational"
> 
> rel_names.dfrel <- function(rel, ...) {
+   df <- unclass(rel)[[1]]
+ 
+   names(df)
+ }
> 
> rel_names(mtcars_rel)
[1] "mpg"  "cyl"  "disp" "hp"  
> 
> 
> 
> cleanEx()
> nameEx("new_relexpr")
> ### * new_relexpr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: new_relexpr
> ### Title: Relational expressions
> ### Aliases: new_relexpr relexpr_reference relexpr_constant
> ###   relexpr_function relexpr_window relexpr_set_alias
> 
> ### ** Examples
> 
> relexpr_set_alias(
+   alias = "my_predicate",
+   relexpr_function(
+     "<",
+     list(
+       relexpr_reference("my_number"),
+       relexpr_constant(42)
+     )
+   )
+ )
List of 3
 $ name : chr "<"
 $ args :List of 2
  ..$ :List of 3
  .. ..$ name : chr "my_number"
  .. ..$ rel  : NULL
  .. ..$ alias: NULL
  .. ..- attr(*, "class")= chr [1:2] "relational_relexpr_reference" "relational_relexpr"
  ..$ :List of 2
  .. ..$ val  : num 42
  .. ..$ alias: NULL
  .. ..- attr(*, "class")= chr [1:2] "relational_relexpr_constant" "relational_relexpr"
 $ alias: chr "my_predicate"
 - attr(*, "class")= chr [1:2] "relational_relexpr_function" "relational_relexpr"
> 
> 
> 
> cleanEx()
> nameEx("stats_show")
> ### * stats_show
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stats_show
> ### Title: Show stats
> ### Aliases: stats_show
> 
> ### ** Examples
> 
> stats_show()
🛠: 10
🔨:  2
🦆:  8
inner_join, mutate, mutate.data.frame
> 
> tibble(a = 1:3) %>%
+   as_duckplyr_df() %>%
+   mutate(b = a + 1)
duckplyr: materializing
# A tibble: 3 × 2
      a     b
  <int> <dbl>
1     1     2
2     2     3
3     3     4
> 
> stats_show()
🛠: 11
🔨:  2
🦆:  9
inner_join, mutate, mutate.data.frame
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.619 0.039 0.661 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
